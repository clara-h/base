{"remainingRequest":"/Users/aa/Desktop/project/base/node_modules/_vue-loader@15.10.1@vue-loader/lib/index.js??vue-loader-options!/Users/aa/Desktop/project/base/src/components/common/scroll/Scroll.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/aa/Desktop/project/base/src/components/common/scroll/Scroll.vue","mtime":1665483372292},{"path":"/Users/aa/Desktop/project/base/node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/aa/Desktop/project/base/node_modules/_babel-loader@8.3.0@babel-loader/lib/index.js","mtime":456789000000},{"path":"/Users/aa/Desktop/project/base/node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/aa/Desktop/project/base/node_modules/_vue-loader@15.10.1@vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\nimport BScroll from 'better-scroll'\nexport default {\n  name: \"Scroll\",\n  props: {\n    probeType: { // 是否监听滚动\n      type: Number,\n      default: 0, // 0,1都是不监听， 3监听\n    },\n    pullUpLoad: {\n     type: Boolean,\n     default: false,\n    }\n  },\n  data() {\n    return {\n      scroll: null,\n    }\n  },\n  mounted() {\n    // 创建BScroll对象\n    this.scroll = new BScroll(this.$refs.wrapper, {\n      click: true, // 只有true状态下，组件内部的div才可被点击，只限制div，不限制button\n      probeType: this.probeType, // 是否触发监听事件\n      pullUpLoad: this.pullUpLoad, // 是否监听上拉事件\n    })\n\n    // 监听滚动的位置\n    if (this.probeType === 2 || this.probeType === 3) {\n      this.scroll.on('scroll', (position) => {\n        this.$emit('scroll', position)\n      })\n    }\n\n    // 监听上拉事件\n    if (this.pullUpLoad) {\n      this.scroll.on('pullingUp', () => {\n        console.log('上拉加载更多')\n        this.$emit('pullingUp', true)\n      })\n    }\n  },\n  methods: {\n    // 滚动方法\n    scrollTo(x, y, time=300) {\n      this.scroll && this.scroll.scrollTo(x, y, time)\n    },\n    // 刷新滚动组件，重新计算高度\n    scrollRefresh() {\n      this.scroll && this.scroll.refresh()\n    },\n    // 结束上拉加载更多(上拉加载只会执行一次，只有这次结束后才会执行下一次)\n    finishPullUp() {\n      this.scroll && this.scroll.finishPullUp()\n    },\n    // 获取y轴距离\n    getScrollY() {\n      return this.scroll ? this.scroll.y : 0\n    }\n  }\n}\n",{"version":3,"sources":["Scroll.vue"],"names":[],"mappings":";AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Scroll.vue","sourceRoot":"src/components/common/scroll","sourcesContent":["<template>\n  <div ref=\"wrapper\">\n    <div class=\"content\">\n      <slot></slot>\n    </div>\n  </div>\n</template>\n\n<script>\nimport BScroll from 'better-scroll'\nexport default {\n  name: \"Scroll\",\n  props: {\n    probeType: { // 是否监听滚动\n      type: Number,\n      default: 0, // 0,1都是不监听， 3监听\n    },\n    pullUpLoad: {\n     type: Boolean,\n     default: false,\n    }\n  },\n  data() {\n    return {\n      scroll: null,\n    }\n  },\n  mounted() {\n    // 创建BScroll对象\n    this.scroll = new BScroll(this.$refs.wrapper, {\n      click: true, // 只有true状态下，组件内部的div才可被点击，只限制div，不限制button\n      probeType: this.probeType, // 是否触发监听事件\n      pullUpLoad: this.pullUpLoad, // 是否监听上拉事件\n    })\n\n    // 监听滚动的位置\n    if (this.probeType === 2 || this.probeType === 3) {\n      this.scroll.on('scroll', (position) => {\n        this.$emit('scroll', position)\n      })\n    }\n\n    // 监听上拉事件\n    if (this.pullUpLoad) {\n      this.scroll.on('pullingUp', () => {\n        console.log('上拉加载更多')\n        this.$emit('pullingUp', true)\n      })\n    }\n  },\n  methods: {\n    // 滚动方法\n    scrollTo(x, y, time=300) {\n      this.scroll && this.scroll.scrollTo(x, y, time)\n    },\n    // 刷新滚动组件，重新计算高度\n    scrollRefresh() {\n      this.scroll && this.scroll.refresh()\n    },\n    // 结束上拉加载更多(上拉加载只会执行一次，只有这次结束后才会执行下一次)\n    finishPullUp() {\n      this.scroll && this.scroll.finishPullUp()\n    },\n    // 获取y轴距离\n    getScrollY() {\n      return this.scroll ? this.scroll.y : 0\n    }\n  }\n}\n</script>\n\n<style scoped>\n\n</style>\n"]}]}